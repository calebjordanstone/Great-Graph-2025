<!doctype html>
<html>
<head>
    <title>UNSW Cognition Lab</title>
    <script src="jatos.js"></script>

    <script src="./resources/js/jquery-3.6.0.min.js"></script>
    <script src="./resources/js/jspsych.js"></script>
    <script src="./resources/js/seedrandom.min.js"></script>
    <script src="./resources/js/plugins/plugin-browser-check.js"></script>
    <script src="./resources/js/plugins/plugin-preload.js"></script>
    <script src="./resources/js/plugins/plugin-demographic-response.js"></script>
    <script src="./resources/js/plugins/plugin-fullscreen.js"></script>
    <script src="./resources/js/plugins/plugin-html-button-response.js"></script>
    <script src="./resources/js/plugins/plugin-html-keyboard-response-mlp.js"></script>
    <script src="./resources/js/plugins/plugin-instructions.js"></script>
    <script src="./resources/js/plugins/plugin-survey-multi-choice-mlp.js"></script>
    <script src="./resources/js/plugins/plugin-survey-text-mlp.js"></script>
    <script src="./resources/js/plugins/plugin-survey-html-form.js"></script>
    <script src="./resources/js/plugins/jspsych-psychophysics-mlp.js"></script>

    <link href="./resources/js/jspsych.css" rel="stylesheet" type="text/css"></link>

    <style>

    .fancyButtonRed {
        display: inline-block;
        padding: 15px 15px;
        font-size: 24px;
        cursor: pointer;
        text-align: center;
        text-decoration: none;
        outline: none;
        color: #fff;
        background-color: #AF504C;
        border: none;
        box-shadow: 0 9px #999;
    }
    .fancyButtonRed:hover {background-color: #8e413e}
    .fancyButtonRed:active {
        background-color: #8e413e;
        box-shadow: 0 5px #666;
        transform: translateY(4px);
    }

    .endTestButton {
        display: inline-block;
        padding: 5px 5px;
        font-size: 110%;
        cursor: pointer;
        text-align: center;
        text-decoration: none;
        outline: none;
        color: #fff;
        background-color: #505050;
        border: 4px solid black;
    }
    .endTestButton:hover {background-color: #8e413e}

    .choiceTestButton {
        padding: 0px 0px;
        width: 200px;
        height: 100px;
        cursor: grab;
        text-align: center;
        outline: none;
        color: #fff;
        background-color: #000000;
        border: 2px solid #808080;
    }
    .choiceTestButton:hover {border: 2px solid white}

    .consentButton {
        display: inline-block;
        padding: 6px 12px;
        margin: 0px;
        font-size: 14px;
        font-weight: 400;
        font-family: 'Open Sans', 'Arial', sans-serif;
        cursor: pointer;
        line-height: 1.4;
        text-align: center;
        white-space: nowrap;
        vertical-align: middle;
        background-image: none;
        border: 1px solid transparent;
        border-radius: 4px;
        color: #333;
        background-color: #B8E9AC;
        border: 2px solid black;
    }
    .consentButton:hover {background-color: #81B474}

    .noConsentButton {
        display: inline-block;
        padding: 6px 12px;
        margin: 0px;
        font-size: 14px;
        font-weight: 400;
        font-family: 'Open Sans', 'Arial', sans-serif;
        cursor: pointer;
        line-height: 1.4;
        text-align: center;
        white-space: nowrap;
        vertical-align: middle;
        background-image: none;
        border: 1px solid transparent;
        border-radius: 4px;
        color: #333;
        background-color: #f09c9c;
        border: 2px solid black;
    }
    .noConsentButton:hover {background-color: #cc8585}

    .conDets {
        font-size: 90%;
        line-height: 120%;
    }

    .row {
        display: flex;
    }

    .column {
        flex: 33.33%;
        padding: 5px;
    }

    /* Chrome, Safari, Edge, Opera */
    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
    }

    /* Firefox */
    input[type=number] {-moz-appearance: textfield;}

    #jspsychTargetMLP {
        text-align: center;
        position: absolute;
        top: 0%;
        left: 50%;
        margin-top: 0;
        margin-left: -400px;
        height: 100%;
        width: 800px;
        overflow-y: auto;
        overflow-x: auto;
        font-family: "Segoe UI", Arial, sans-serif;
        font-size: 110%;
        color: black;
    }

    body {background-color: white;}
    html, body {
        margin: 0;
        height: 100%;
        width: 100%;
    }

    </style>
</head>

<body>
    <div id="jspsychTargetMLP"></div>
</body>
<script>

// ******************* this needs to be on top to run jspsych.js ******************

const jsPsych = initJsPsych({
    display_element: 'jspsychTargetMLP',
    on_finish: function() {
      jsPsych.data.displayData()
        document.write('<div id="endscreen" class="endscreen" style="width:100%"><div class="endscreen" style="text-align:center; font-family:Segoe UI, Arial, sans-serif; font-size:130%;line-height:160%;margin:0 auto"><p><br><br><br>' +finish_msg +'</p></div></div>')
    },
});

// ******************* start ******************

document.body.style.backgroundColor = "hsl(0,0%,"+lightnessVal+"%)";

var realVersion = true;
var jatosVersion = false;
var sonaVersion = false;
var prolificVersion = true;

console.log('e1_v2b');
console.log('realVersion: ' + realVersion);
console.log('jatosVersion: ' + jatosVersion);
console.log('sonaVersion: ' + sonaVersion);
console.log('prolificVersion: ' + prolificVersion);

if (sonaVersion && prolificVersion) {throw('Cannot have both sonaVersion and prolificVersion as true')}

if (sonaVersion == true){
  var sample = 'SONA';
}else if (prolificVersion == true){
  var sample = 'Prolific';
}



var exptPhase = 0;      // 0 = practice, 1 = main task
var instSet = 0;

Math.seedrandom();
rSeed = Math.floor(Math.random()*9999999);
Math.seedrandom(rSeed);

const numStimLocs = 54;

//Group manipulation
var LearningConditions = ["Experience","Instructed"];
let LearningCondition = jsPsych.randomization.sampleWithoutReplacement(LearningConditions, 1);

//Information about colours
var colourBalanceGroup = ["OrangeFirst","BlueFirst"]; //Whether the sequence starts with an Orange or Blue Plateau - this means the optimal search strategy is to search for the OTHER colour first (trialType 1 = search Blue if OrangeFirst)
let colourBalance = jsPsych.randomization.sampleWithoutReplacement(colourBalanceGroup, 1); //start sequence with plateau orange or plateau blue

//specify colours
if (colourBalance == "OrangeFirst"){
  var target_colourStr = ['rgb(196, 78, 0)','rgb(0, 0, 255)']; //orange[0] then blue[1] 4, 217, 255
  var target_colourName = ['ORANGE','BLUE'];
}else if (colourBalance == "BlueFirst"){
  var target_colourStr = ['rgb(0, 0, 255)','rgb(196, 78, 0)']; //blue[0] then orange[1]
  var target_colourName = ['BLUE','ORANGE'];
}

var target_colour1 = target_colourStr[0];
var target_colour2 = target_colourStr[1];
var target_colourName1 = target_colourName[0];
var target_colourName2 = target_colourName[1];

const greenStr = 'rgb(0, 150, 0)';
var IrrColour = greenStr;
var IrrColourName = 'GREEN';

//Number of items by type
const TargetColourNum = 13; //includes the target - same for both target1 and target2 colour so x2
const IrrColourNum = 14; //irrelevant distractor items, always green
const VarColourNum = 14;

//Information about numbers
const target_numbers = [2,3,4,5];
const distractor_numbers = [6,7,8,9];

var subject_id = 0;
var results_id = 0;

var prizeStr = 'a bonus of 2 GBP';
var prizeStrShort = prizeStr;

var locArray = [];
for (ii = 0; ii < numStimLocs; ii++) {locArray[ii] = ii};

var fieldsToIgnore = ['internal_node_id', 'stimulus', 'view_history', 'question_order', 'success', 'failed_images', 'failed_audio', 'failed_video', 'timeout', 'center_x', 'center_y', 'mobile'];

var winWidth = 800;

if (realVersion) {
    var initialPauseDuration = 1000;
    var time_fixation = 500;
    var time_blankAfterFixation = 0;
    var start_after_fixation = time_fixation + time_blankAfterFixation;
    var timeout_duration = 7500 + start_after_fixation;           // actual timeout at 7.5s after display onset
    var time_blankAfterMemTarget = 150;
    var time_choiceArray = 500;
    var time_maskDisplay = 100;
    var time_iti = 900;
    var feedback_duration = 1;
    var errorfeedback_duration = 3500;

    var time_minFB_prac = 1;
    var time_minFB_main = 1;

    var numChoicePracTrials = 8; //don't forget to also change prac_block sequence on line 474
    var pracTimeout = 8000;

    var numBlocks = 1;
    var prompt_duration = 2500; //text before fixation screen

} else {
    var initialPauseDuration = 1;     // 1000
    var time_fixation = 1;    // 500
    var time_blankAfterFixation = 0;
    var timeout_duration = 8000;           // 800
    var time_blankAfterMemTarget = 1;     // 150
    var time_choiceArray = 1;     // 400
    var time_maskDisplay = 1;     // 100
    var time_iti = 1;

    var feedback_duration = 1;
    var errorfeedback_duration = 1;

    var time_minFB_prac = 1;
    var time_minFB_main = 10;

    var numChoicePracTrials = 8;
    var pracTimeout = 8000;

    var numBlocks = 1;
    var prompt_duration = 1;

}

// ******************* SET TRIAL TYPES ******************

// Function to generate valid target locations
function getValidTargetLocation(target1Location, offsets, totalLocations) {
    let target2Location;
    do {
        const offsetIndex = Math.floor(Math.random() * offsets.length); // Generate random index
        const offset = offsets[offsetIndex]; // Get offset value at random index
        target2Location = (target1Location + offset + totalLocations) % totalLocations;
    } while (
        target2Location === target1Location );

    return target2Location;
}

// Create random distractor location for practice trials
function getNext(target1Location) {
    const target2Location = getValidTargetLocation(target1Location, targetOffsetArray, numStimLocs);
    return { target1Location, target2Location };
}

//-------------------------------------//
const targetOffsetArray = Array.from({ length: numStimLocs }, (_, i) => i + 1).filter(offset => offset !== 0);

const sequenceRepeats = 3;
const trialsPerSequence = 18;
const blockSize = sequenceRepeats*trialsPerSequence; //This is just total number of trials in a block



let target_location_array = [];

for (let i = 0; i < blockSize*numBlocks; i++) {
    const target1Location = Math.floor(Math.random() * numStimLocs); // Randomly pick first target location
    const result = getNext(target1Location);

    // Push the trial object to the array
    target_location_array.push(result);
}

function sampleLocationsPerBlock() {
  targetLocationPairs = jsPsych.randomization.sampleWithoutReplacement(target_location_array, blockSize);

  shuffleArray(targetLocationPairs);

  if (jatosVersion == false) {
    console.log("New target locations selected:", {
        targetLocationPairs
    });
  }
}

//function to get two unique target numbers on each trial
let targetNumberPairs = [];
for (let i = 0; i < blockSize*numBlocks; i++) {
  const pair = jsPsych.randomization.sampleWithoutReplacement(target_numbers, 2);

  // Create an object with targetnum1 and targetnum2
  const targetPairObject = {
    targetnum1: pair[0],
    targetnum2: pair[1]
  };

  targetNumberPairs.push(targetPairObject);
}

function sampleNumbersPerBlock() {
  targetNumPairs = jsPsych.randomization.sampleWithoutReplacement(targetNumberPairs, blockSize);
  shuffleArray(targetNumPairs);

  if (jatosVersion == false) {
    console.log("New target number pairs selected:", {
        targetNumPairs
    });
  }
}


//practice blocks
let prac_target_location_array =[];
for (let i = 0; i < numChoicePracTrials; i++) {
    const target1Location = Math.floor(Math.random() * numStimLocs); // Randomly pick first target location
    const result = getNext(target1Location);

    // Push the trial object to the array
    prac_target_location_array.push(result);
}

let prac_targetNumberPairs = [];
for (let i = 0; i < numChoicePracTrials; i++) {
  const pair = jsPsych.randomization.sampleWithoutReplacement(target_numbers, 2);

  // Create an object with targetnum1 and targetnum2
  const targetPairObject = {
    targetnum1: pair[0],
    targetnum2: pair[1]
  };

  prac_targetNumberPairs.push(targetPairObject);
}


//Generate trial types in a sequence//

let blockSequence = [];
for (ii = 0; ii < sequenceRepeats; ii++) {
  const sequenceTT = [1,1,2,3,4,5,6,7,8,8,8,7,6,5,4,3,2,1] //18 trials across 2 sequences (drop 2 of them)
  //drop 1 trial, Transition 1-8, drop 1 trial, Transition 1-8 reverse order

  blockSequence = blockSequence.concat(sequenceTT);
}

// Map trial types to the number of variable color items that match the target color
const trialTypeToVarColorMatch = {
  1: 14,   // Trial type 1: all variable colours match target1 colour
  2: 12,
  3: 10,
  4: 8,
  5: 6,
  6: 4,
  7: 2,
  8: 0   // Trial type 8: all variable colours match target 2 colour
};

let trialColorCounts = [];
// Iterate over the blockSequence to calculate the number of different colored items for each trial type
for (let trial of blockSequence) {
  // For each trial, get the number of variable color items that match the target color
  const varColorMatches = trialTypeToVarColorMatch[trial];

  // The number of target color items is always 13 (TargetColourNum)
  const target1ColorItems = TargetColourNum + varColorMatches;
  const target2ColorItems = TargetColourNum + (VarColourNum-varColorMatches);

  // The number of irrelevant color items is always 14 (IrrColourNum)
  const irrelevantColorItems = IrrColourNum;

  // Calculate the total number of different colored items for this trial

  const totalColoredItems = target1ColorItems + target2ColorItems + irrelevantColorItems;

  // Store the result for this trial
  trialColorCounts.push({
    trialType: trial,
    target1ColorItems: target1ColorItems,
    target2ColorItems: target2ColorItems,
    irrelevantColorItems: irrelevantColorItems
  });
}


var numTrialsPerBlock = trialColorCounts.length; //90

//generating new list for practice trials - bit redundant
let pracs_per_block =[];
// Generate trials with valid target locations
for (let i = 0; i < numChoicePracTrials; i++) {
    // Get random distractor location
    const distractorLocation = Math.floor(Math.random() * numStimLocs);

    // Get next trial with valid target location
    const trial = getNext(distractorLocation);

    // Push the trial object to the array
    pracs_per_block.push(trial);
}

let prac_block = [1,1,1,1,8,8,8,8]; //only use plateau trials
shuffleArray(prac_block);

let prac_trialColorCounts = [];
// Iterate over the blockSequence to calculate the number of different colored items for each trial type
for (let trial of prac_block) {
  // For each trial, get the number of variable color items that match the target color
  const varColorMatches = trialTypeToVarColorMatch[trial];

  // The number of target color items is always 13 (TargetColourNum)
  const target1ColorItems = TargetColourNum + varColorMatches;
  const target2ColorItems = TargetColourNum + (VarColourNum-varColorMatches);

  // The number of irrelevant color items is always 14 (IrrColourNum)
  const irrelevantColorItems = IrrColourNum;

  // Calculate the total number of different colored items for this trial

  const totalColoredItems = target1ColorItems + target2ColorItems + irrelevantColorItems;

  // Store the result for this trial
  prac_trialColorCounts.push({
    trialType: trial,
    target1ColorItems: target1ColorItems,
    target2ColorItems: target2ColorItems,
    irrelevantColorItems: irrelevantColorItems
  });
}



// ******************* CREATE AND SET VARIOUS USEFUL VARIABLES ******************

var ItemSize = 40;

var blockNum = 0;
var overallBlockNum = 0;
var trialNum = 0;
var trialNumInBlock = 0;
var totalPoints = 0;
var blockCorrect = 0;
var totalCorrect = 0;
var totalNumTrials = 0;
var totalRT = 0;
var totalValidTrials = 0;

var p_age = '';
var p_gender = '';
var p_language = '';

// var goodBlockScore = Math.floor(numTrialsPerBlock * numStimLocs/2);
// var pointsPerMedal = Math.floor(goodBlockScore * numBlocks / 6);  // Divided by 6 as Elite is level 6, and rounded down to nearest 100
// if (realVersion == false) {console.log('ppm ' + pointsPerMedal)};

var trialType;


var trialOffsetAngle;


// *****************************************

const PromptText = {
    obj_type: 'text',
    font: "28px 'Arial'",
    origin_center: true,
    text_color: 'white',
}

const fixationObject = {
    obj_type: 'cross',
    line_length: 20,
    line_width: 3,
    line_color: 'white',
    show_end_time: time_fixation,
}


var SearchObjectArray = [];
var SearchObjectNum = [];

for (ii = 0; ii < numStimLocs; ii++) {
  SearchObjectArray[ii] = {
    obj_type: 'square',
    size: ItemSize,
    origin_center: true,
  }

  SearchObjectNum[ii]= {
    obj_type: 'text',
    text_color: 'white',
    content: (ii + 1).toString(),
    font: "20px Arial, monospace",
    origin_center: true,
  }
}



const fbText1 = {
    obj_type: 'text',
    font: "24px 'Arial'",
    text_color: 'white',
    text_space: 64,
}



var trialType;

// var practiceLocationIndex = 0;

const prompt_screen = {
  type: jsPsychPsychophysicsMLP,
  stimuli: function() {

    target1ColorItems = undefined;
    target2ColorItems = undefined;
    irrelevantColorItems = undefined;

    var stimArray = [];
    var tempStr = '';

    if (exptPhase == 0){
      trialType = prac_trialColorCounts[trialNumInBlock].trialType;
      target1ColorItems = prac_trialColorCounts[trialNumInBlock].target1ColorItems;
      target2ColorItems = prac_trialColorCounts[trialNumInBlock].target2ColorItems;
      irrelevantColorItems = prac_trialColorCounts[trialNumInBlock].irrelevantColorItems;

    } else if (exptPhase > 0) {
      trialType = trialColorCounts[trialNumInBlock].trialType;
      target1ColorItems = trialColorCounts[trialNumInBlock].target1ColorItems;
      target2ColorItems = trialColorCounts[trialNumInBlock].target2ColorItems;
      irrelevantColorItems = trialColorCounts[trialNumInBlock].irrelevantColorItems;
    }

    num_TargetColour1 = target1ColorItems.toString();
    num_TargetColour2 = target2ColorItems.toString();

    if (LearningCondition == "Experience"){
      tempStr = 'The next trial is about to begin';
    } else if (LearningCondition == "Instructed"){
      tempStr = 'The next trial will have '+num_TargetColour1+' '+target_colourName1+' squares and\n\n'+num_TargetColour2+' '+target_colourName2+' squares.';
    }

    PromptText.content = tempStr;
    stimArray.push(PromptText);

    return stimArray;
  },
  canvas_width: 800,
  canvas_height: 600,
  background_color: 'black',
  choices: "NO_KEYS",
  response_ends_trial: false,
  // response_start_time: start_after_fixation, //changing this so responding can only happen after fixation - rt data now saves without fixation time
  trial_duration: prompt_duration,
  post_trial_gap: time_iti,
  on_finish: function(data) {
    jsPsych.data.get().addToLast({
        phase: 'promptScreen'
    });
  }
};

var RTarray = [];

const search_display = {
  type: jsPsychPsychophysicsMLP,
  stimuli: function() {

    target_num1 = undefined;
    target_num2 = undefined;

    target1Location = undefined;
    target2Location = undefined;

    target1ColorItems = undefined;
    target2ColorItems = undefined;
    irrelevantColorItems = undefined;


    var stimArray = [];
    stimArray.push(fixationObject); // Add the fixation object to the stimulus array

    if (exptPhase == 0){
      Target_Locations = prac_target_location_array[trialNumInBlock];
      Target_numberPairs = prac_targetNumberPairs[trialNumInBlock];
      // Get trial type and the corresponding color counts
      trialType = prac_trialColorCounts[trialNumInBlock].trialType;
      target1ColorItems = prac_trialColorCounts[trialNumInBlock].target1ColorItems;
      target2ColorItems = prac_trialColorCounts[trialNumInBlock].target2ColorItems;
      irrelevantColorItems = prac_trialColorCounts[trialNumInBlock].irrelevantColorItems;

    } else if (exptPhase > 0) {
        // Get the target locations and numbers for the current trial
        Target_Locations = targetLocationPairs[trialNumInBlock];
        Target_numberPairs = targetNumPairs[trialNumInBlock];

        // Get trial type and the corresponding color counts
        trialType = trialColorCounts[trialNumInBlock].trialType;
        target1ColorItems = trialColorCounts[trialNumInBlock].target1ColorItems;
        target2ColorItems = trialColorCounts[trialNumInBlock].target2ColorItems;
        irrelevantColorItems = trialColorCounts[trialNumInBlock].irrelevantColorItems;
    }

    target1Location = Target_Locations.target1Location;
    target2Location = Target_Locations.target2Location;
    target_num1 = Target_numberPairs.targetnum1;
    target_num2 = Target_numberPairs.targetnum2;

    target_num1 = target_num1;
    target_num2 = target_num2;
    targets_thistrial = [target_num1, target_num2];

    //remove target numbers from potential target number array
    //have to do all this in the trial because the target numbers change every trial
    irr_targetnumbers = target_numbers.filter(function(item){
      return !targets_thistrial.includes(item)
    });

    //pick one of the remaining numbers from the target number array
    irr_targetnumber = jsPsych.randomization.sampleWithReplacement(irr_targetnumbers, 1);

    //add that 1 number to the distractor number array
    //This means that the irrelevant colour will always only have one number between 2-5 and it is never the target numbers
    let combine_numbers = irr_targetnumber.concat(distractor_numbers);
    shuffleArray(combine_numbers); //probably unnecessary since it rand selects anyways



    //create array of locations that are not the target locations
    let otherLocations = [];
    for (let i = 0; i < numStimLocs; i++) {
      if (i !== target1Location && i !== target2Location) {
        otherLocations.push(i);
      }
    }

    //subset the non-target locations based on the number of different coloured squares on that trial
    let colour1_locations = [];
    let colour2_locations = [];
    let irrColour_locations = [];

    // Shuffle the otherLocations array
    shuffleArray(otherLocations);

    // Select target1ColorItems-1 items for colour1_locations (-1 because take out target)
    colour1_locations = otherLocations.slice(0, target1ColorItems - 1);

    // Select target2ColorItems-1 items for colour2_locations
    colour2_locations = otherLocations.slice(
      target1ColorItems - 1,
      target1ColorItems - 1 + target2ColorItems - 1 //starts from where you left off with colour1_locations
    );

    // Select IrrColourNum items for irrColour_locations
    irrColour_locations = otherLocations.slice(
      target1ColorItems - 1 + target2ColorItems - 1,
      target1ColorItems - 1 + target2ColorItems - 1 + irrelevantColorItems
    );

    if (jatosVersion == false){
      console.log("colour1_locations:", colour1_locations);
      console.log("colour2_locations:", colour2_locations);
      console.log("irrColour_locations:", irrColour_locations);

      console.log("target1_number:",target_num1);
      console.log("target2_number:", target_num2);
      console.log("trialTypeInSequence", trialType);

    }


    // Determine the available locations for the targets and other items
    for (let ii = 0; ii < numStimLocs; ii++) {
      if (ii == target1Location){
        SearchObjectNum[ii].content = target_num1.toString();
        SearchObjectArray[ii].fill_color = target_colour1;
      }else if (ii == target2Location){
        SearchObjectNum[ii].content = target_num2.toString();
        SearchObjectArray[ii].fill_color = target_colour2;
      }else if (colour1_locations.includes(ii)){
        let nontarget_number_select = jsPsych.randomization.sampleWithReplacement(distractor_numbers, 1);
        SearchObjectNum[ii].content = nontarget_number_select.toString();
        SearchObjectArray[ii].fill_color = target_colour1;
      }else if (colour2_locations.includes(ii)){
        let nontarget_number_select = jsPsych.randomization.sampleWithReplacement(distractor_numbers, 1);
        SearchObjectNum[ii].content = nontarget_number_select.toString();
        SearchObjectArray[ii].fill_color = target_colour2;
      }else if (irrColour_locations.includes(ii)){
        let distractor_number_select = jsPsych.randomization.sampleWithReplacement(combine_numbers, 1);
        SearchObjectNum[ii].content = distractor_number_select.toString();
        SearchObjectArray[ii].fill_color = IrrColour;
      }
    }


    // Push all objects into the stimArray
    for (let ii = 0; ii < numStimLocs; ii++) {
      stimArray.push(SearchObjectArray[ii]);
      stimArray.push(SearchObjectNum[ii]);
    }

    return stimArray;
  },
  response_type: 'key',
  choices: ['2', '3', '4', '5','numpad2','numpad3','numpad4','numpad5'],
  response_ends_trial: true,
  response_start_time: start_after_fixation, //changing this so responding can only happen after fixation - rt data now saves without fixation time
  canvas_width: 800,
  canvas_height: 800,
  background_color: 'black',
  trial_duration: function(){
    if (exptPhase > 0){
      return timeout_duration;
    } else {
      return pracTimeout;
    }
  },
  on_finish: function(data) {

    data.target_num1 = target_num1;
    data.target_num2 = target_num2;
    data.irr_targetnum = irr_targetnumber[0];

    if (data.response !== null) {
      if (data.response === data.target_num1.toString()) {
        data.selectedColour = target_colourName1;
        data.responseAccuracy = 1;
        data.timeout_trial = 0;
      } else if (data.response === data.target_num2.toString()) {
        data.selectedColour = target_colourName2;
        data.responseAccuracy = 1;
        data.timeout_trial = 0;
      } else {
        data.selectedColour = 'unknown';
        data.responseAccuracy = 0;
        data.timeout_trial = 0;
      }
    } else {
      data.selectedColour = null;
      data.responseAccuracy = 0;
      data.timeout_trial = 1;
    }

    if (exptPhase > 0) {
      totalRT += data.rt;
      if (data.rt !== null) {
        totalValidTrials++; // Increment valid trial count
        if (data.responseAccuracy === 1){
          RTarray.push(data.rt);
        }
      }
    }

    // Add trial data to the session
    jsPsych.data.get().addToLast({
      phase: 'search',
      exptPhase: exptPhase,
      blockNum: blockNum,
      trialNum: trialNum,
      trialNumInBlock: trialNumInBlock,
      trialType: trialType,
      target1ColorItems: target1ColorItems,
      target2ColorItems: target2ColorItems,
      irrelevantColorItems: irrelevantColorItems,
      target1Location: target1Location,
      target2Location: target2Location,
      targetNumber1: target_num1,
      targetNumber2: target_num2
    });
  }
};


const feedbackTrial = {
    type: jsPsychPsychophysicsMLP,
    stimuli: function() {

        const data = jsPsych.data.get().last(1).values()[0];
        const { response, responseAccuracy, timeout_trial} = data;


        var stimArray = [];
        var tempStr = '';

        if (timeout_trial === 1) {
          tempStr = 'TOO SLOW!';
          trialCorrect = 0;
        } else if (responseAccuracy === 1 && timeout_trial === 0) {
          trialCorrect = 1;
        } else if (responseAccuracy === 0 && timeout_trial === 0) {
          tempStr = 'INCORRECT';
          trialCorrect = 0;
        }

        fbText1.content = tempStr;
        fbText1.startY = 'center';
        stimArray.push(fbText1);

        if (exptPhase > 0) {
          blockCorrect += trialCorrect;
          totalCorrect += trialCorrect;
          totalNumTrials++;
        }

        return stimArray;
    },
    canvas_width: 800,
    canvas_height: 600,
    background_color: 'black',
    choices: "NO_KEYS",
    response_ends_trial: false,
    trial_duration: function() {
      const data = jsPsych.data.get().last(1).values()[0];
      const { response,responseAccuracy, timeout_trial } = data;

      if (responseAccuracy === 1){
        return feedback_duration;
      } else {
        return errorfeedback_duration;
      }
    },
    post_trial_gap: time_iti,
    on_finish: function(data) {
        jsPsych.data.get().addToLast({
            phase: 'feedback'
        });
    }
};


//Based on Irons & Leber (2016)
const run_trial_display = {
    on_timeline_start: function() {
        // Constants for the rings
        const radii = [190, 1.5*190, 2*190]; // Radii of the three rings in degrees - 240pixels inner radius in original code
        const numItems = [12, 18, 24]; // Number of items in each ring
        const distanceBetweenItems = 3.6; // Distance between items in degrees
        const trialOffsetAngle = 0; // Angle offset for item positioning
        const trialOffsetAngleRads = trialOffsetAngle * (Math.PI / 180);

        let index = 0; // Index to track overall item count

        // Loop through each ring
        for (let ring = 0; ring < radii.length; ring++) {
            const radius = radii[ring]; //
            const itemsInRing = numItems[ring];

            // Calculate the angle step between each item in the ring
            const angleStep = (2 * Math.PI) / itemsInRing;

            // Place items in the current ring
            for (let i = 0; i < itemsInRing; i++) {
                const angle = trialOffsetAngleRads + i * angleStep;

                // Calculate positions
                const x = -radius * Math.sin(angle);
                const y = -radius * Math.cos(angle);

                // Assign positions to the SearchObjectArray and SearchObjectLine
                SearchObjectArray[index].startX = x;
                SearchObjectArray[index].startY = y;
                SearchObjectNum[index].startX = x;
                SearchObjectNum[index].startY = y+2; //numbers not centered without correction

                // Set timing properties
                SearchObjectArray[index].show_start_time = fixationObject.show_end_time + time_blankAfterFixation;
                SearchObjectNum[index].show_start_time = SearchObjectArray[index].show_start_time;
                SearchObjectArray[index].show_end_time = SearchObjectArray[index].show_start_time + timeout_duration;
                SearchObjectNum[index].show_end_time = SearchObjectArray[index].show_end_time;

                // Move to the next index for the next item
                index++;
            }
        }
    },
    timeline: [search_display]
};



const run_full_trial = {timeline: [prompt_screen, run_trial_display, feedbackTrial]};

const run_prac_trial = {timeline:[prompt_screen, run_trial_display, feedbackTrial]};


//change to pre-main experiment instructions
var numBreaks = 1;

const blockBreakScreen1 = {
    type: jsPsychHtmlKeyboardResponseMLP,
    stimulus: function() {

        var tempTextHTML = "<p style='white-space:pre;'>Time for a break!<br><br>Sit back, relax for a moment! You may continue whenever you're ready.</p>";
        tempTextHTML = "<p style='white-space:pre;'>" + (numBreaks) +" of " + numBlocks + " blocks completed.</p>";     // Add 1 to total blocks to include practice phase //(numBlocks*2) for larger block sizes
        tempTextHTML += "<p>In the previous block, you made the correct response on " + Math.round(100*blockCorrect/(numTrialsPerBlock)) + "% of trials.</p>";
        tempTextHTML += "<p>Your average response time to report the number in the target shape was "+ Math.round(totalRT/totalValidTrials) +" ms.</p>";

        blockCorrect = 0;
        totalRT = 0;
        totalValidTrials = 0;
        numBreaks++;

        // if (newMedal) {tempTextHTML += "<p style='color:yellow; font-size:115%'>You\'ve unlocked a new medal!</p>"};

        // tempTextHTML += '<p>'
        // for (ii = 0; ii < currentMedalLevel; ii++) {
        //     if (ii == currentMedalLevel-1) {
        //         tempTextHTML += '<img src="' + medalImgStr[ii] + '">'
        //     } else {
        //         tempTextHTML += '<img src="' + medalImgStr[ii] + '" style="opacity:0.4">'
        //     };
        // };
        tempTextHTML += '<br><br></p>';
        tempTextHTML += "<p>Press space when you are ready to continue</p>"
        pointsInBlock = 0;
        return tempTextHTML;
    },
    choices: [' '],
    check_focus_interval: 1500,
    post_trial_gap: 0,
    on_finish: function() {
        // jsPsych.data.get().addToLast({
        //     currentMedal: currentMedalLevel
        // });
        if (jatosVersion == true) {
            // var result_for_JATOS = jsPsych.data.get().ignore(fieldsToIgnore).json();
            var result_for_JATOS = jsPsych.data.get().ignore(fieldsToIgnore).csv();
            jatos.submitResultData(result_for_JATOS);
        };
    }
};

const instructions_afterPractice = {
    type: jsPsychHtmlKeyboardResponseMLP,
    stimulus: function() {
        var tempTextHTML = "<p style='font-size:130%; line-height:160%'><span style='color:yellow;'><b>PRACTICE COMPLETE!</b>"+
        "</span><br>You are almost ready to start the experiment.<br>Just a few more instructions before you begin.<br><br></p>"; //need to change this instructions
        tempTextHTML += "<p>Press space when you are ready to continue</p>"
        blockMemCorrect = 0;
        return tempTextHTML;
    },
    choices: [' '],
    check_focus_interval: 1500,
    post_trial_gap: 0,
};


const end_searchtask = {
    type: jsPsychHtmlKeyboardResponseMLP,
    stimulus: function() {
        var tempTextHTML = "<p style='font-size:130%; line-height:160%'><span style='color:red;'><b>CHOICE SEARCH TASK COMPLETE!</b>"+
        "</span><br>We will now ask you a few questions about the search task you have just completed. Please take your time and try to be as accurate as possible in your response.<br><br></p>";
        tempTextHTML += "<p>Press space when you are ready to continue</p>"
        return tempTextHTML;
    },
    choices: [' '],
    check_focus_interval: 1500,
    post_trial_gap: 0,
};

const test_strategy = {
    type: jsPsychSurveyMultiChoiceMLP,
    questions: [
      {
        prompt: 'During the search task, you were free to choose whether to search for the '+target_colourName1+' or '+target_colourName2+' target in each display.<br><br><b>Which of the following best describes how YOU decided which coloured target to search for on any given trial?</b>',
        name: 'StrategyChoice',
        options: [
          'I searched for a single colour for an extended period of time and avoided switching between colours.',
          'I searched for the target with the fewest number of same-colour (distractor) squares.',
          'I had no particular strategy and decided on the fly which target to search for.'
        ],
        required: true
      },
    ],
    data: {
        phase: 'StrategyChoice'
      }
};

const test_strategy_freeResponse = {
    type: jsPsychSurveyTextMLP,
    questions: [
      {
        prompt: '<b>Please tell us more about your strategy during the choice search task.</b><br><br>In particular, we want to know if you STUCK TO ONE strategy for most of the experiment or<br>SWITCHED BETWEEN different strategies.<br><br>Any information you can provide is greatly appreciated.',
        name: 'StrategySwitch',
        rows: 10,
        columns: 80,
        required: true
      }
    ],
    data: {
        phase: 'StrategyChoiceFreeResponse'
      }
};

const test_aware_change = {
    type: jsPsychSurveyMultiChoiceMLP,
    questions: [
      {
        prompt: 'During the search task, the number of ' + target_colourName1 + ' and ' + target_colourName2 + ' squares changed in each display.<br><br><b>Which of the following best describes what YOU noticed about changes in the display?</b>',
        name: 'ChangeAwareness',
        options: [
          'Changes in the number of '+target_colourName1+' and '+target_colourName2+' squares happened RANDOMLY from trial to trial; There was no systematic pattern in how the number of different colour squares changed from trial to trial.',
          'Changes in the number of '+target_colourName1+' and '+target_colourName2+' squares happened SEQUENTIALLY; The number of majority-colour squares gradually decreased over a sequence and were replaced by squares in the other colour.',
          'I did not notice any change in the number of '+target_colourName1+' and '+target_colourName2+' squares across the experiment.'
        ],
        required: true
      },
    ],
    data: {
        phase: 'ChangeAwareness'
      }
};


const instr_commonColour = {
    type: jsPsychHtmlKeyboardResponseMLP,
    stimulus: function() {
        var tempTextHTML = "<p style='font-size:130%; line-height:160%'><span style='color:red;'><b>Your response has been recorded.</b>"+
        "</span><br>On the next few screens, you will see a series of different displays from the Choice Search Task. For each display, you are asked to decide whether there are more "+target_colourName1+" or "+target_colourName2+" squares.<br><br>"+
        "Please try not to take too long to make your choice, but use your general impression of the overall proportion of "+target_colourName1+" and "+target_colourName2+" squares in the display to make your decision."+
        "<br>The trial will timeout if you take too long to respond!</p>";
        tempTextHTML += "<p>Press space when you are ready to continue</p>"
        blockMemCorrect = 0;
        return tempTextHTML;
    },
    choices: [' '],
    check_focus_interval: 1500,
    post_trial_gap: 0,
};

var imageFolder = 'resources/images/';

var test_tt1_v1_filename = imageFolder + 'test_tt1_' + target_colourName1 + '.png'; //plateau1
var test_tt2_v1_filename = imageFolder + 'test_tt2_' + target_colourName1 + '.png';
var test_tt3_v1_filename = imageFolder + 'test_tt3_' + target_colourName1 + '.png';
var test_tt4_v1_filename = imageFolder + 'test_tt4_' + target_colourName1 + '.png';
var test_tt5_v1_filename = imageFolder + 'test_tt5_' + target_colourName1 + '.png';
var test_tt6_v1_filename = imageFolder + 'test_tt6_' + target_colourName1 + '.png';
var test_tt7_v1_filename = imageFolder + 'test_tt7_' + target_colourName1 + '.png';
var test_tt8_v1_filename = imageFolder + 'test_tt8_' + target_colourName1 + '.png'; //plateau2

var test_tt8_v2_filename = imageFolder + 'test_tt1_' + target_colourName2 + '.png'; //plateau2
var test_tt7_v2_filename = imageFolder + 'test_tt2_' + target_colourName2 + '.png';
var test_tt6_v2_filename = imageFolder + 'test_tt3_' + target_colourName2 + '.png';
var test_tt5_v2_filename = imageFolder + 'test_tt4_' + target_colourName2 + '.png';
var test_tt4_v2_filename = imageFolder + 'test_tt5_' + target_colourName2 + '.png';
var test_tt3_v2_filename = imageFolder + 'test_tt6_' + target_colourName2 + '.png';
var test_tt2_v2_filename = imageFolder + 'test_tt7_' + target_colourName2 + '.png';
var test_tt1_v2_filename = imageFolder + 'test_tt8_' + target_colourName2 + '.png'; //plateau2

var testImages = [];
// allImageFilenames.push(medalDisplayFilename);
testImages.push(test_tt1_v1_filename);
testImages.push(test_tt2_v1_filename);
testImages.push(test_tt3_v1_filename);
testImages.push(test_tt4_v1_filename);
testImages.push(test_tt5_v1_filename);
testImages.push(test_tt6_v1_filename);
testImages.push(test_tt7_v1_filename);
testImages.push(test_tt8_v1_filename);
testImages.push(test_tt1_v2_filename);
testImages.push(test_tt2_v2_filename);
testImages.push(test_tt3_v2_filename);
testImages.push(test_tt4_v2_filename);
testImages.push(test_tt5_v2_filename);
testImages.push(test_tt6_v2_filename);
testImages.push(test_tt7_v2_filename);
testImages.push(test_tt8_v2_filename);

const preload_test_images = {
    type: jsPsychPreload,
    auto_preload: false,
    show_progress_bar: false,
    images: testImages,
};


var choice_timeline_variables = [
  { stimulus: test_tt1_v1_filename, name: 'Plateau_Colour1' },
  { stimulus: test_tt1_v2_filename, name: 'Plateau_Colour1' },
  { stimulus: test_tt2_v1_filename, name: 'Transition1_Colour1' },
  { stimulus: test_tt2_v2_filename, name: 'Transition1_Colour1' },
  { stimulus: test_tt3_v1_filename, name: 'Transition2_Colour1' },
  { stimulus: test_tt3_v2_filename, name: 'Transition2_Colour1' },
  { stimulus: test_tt4_v1_filename, name: 'Transition3_Colour1' },
  { stimulus: test_tt4_v2_filename, name: 'Transition3_Colour1' },
  { stimulus: test_tt5_v1_filename, name: 'Transition4_Colour1' },
  { stimulus: test_tt5_v2_filename, name: 'Transition4_Colour1' },
  { stimulus: test_tt6_v1_filename, name: 'Transition5_Colour1' },
  { stimulus: test_tt6_v2_filename, name: 'Transition5_Colour1' },
  { stimulus: test_tt7_v1_filename, name: 'Transition6_Colour1' },
  { stimulus: test_tt7_v2_filename, name: 'Transition6_Colour1' },
  { stimulus: test_tt8_v1_filename, name: 'Plateau_Colour2' },
  { stimulus: test_tt8_v2_filename, name: 'Plateau_Colour2' }
];



let choice_timeout_duration = null;
let trials_to_repeat = []; // Store missed trials to be re-added

var CommonColourChoice_trial = {
  type: jsPsychHtmlButtonResponse,
  timeline_variables: choice_timeline_variables,
  // prompt: '<p style="text-align:center">Are there more '+target_colourName1+' or '+target_colourName2+' squares in the display?',
  stimulus: function(){
    // Embed the stimulus image in an HTML string
    var stimulusPath = jsPsych.timelineVariable('stimulus');
    return `
    <p style="text-align:center"><b>Are there more ${target_colourName1} or ${target_colourName2} squares in the display?</b></p>
    <p style="text-align:center"><br><img src="${stimulusPath}" style="width:70%;height:70%;"></p>`;
  },
  choices: ['<p style="font-size:130%;line-height:120%;"><b>There are more<br>'+target_colourName1+' squares</b></p>', '<p style="font-size:130%;line-height:120%;"><b>There are more<br>'+target_colourName2+' squares</b></p>'],
  button_html: ['<button class="choiceTestButton" style="vertical-align:middle;width:200px;"><span>%choice%</span></button><br><br>', '<button class="choiceTestButton" style="vertical-align:middle;width:200px;"><span>%choice%</span></button><br><br>'],
  margin_horizontal: '50px',
  randomize_order: true,
  trial_duration: function(){
    let upperQuartileRT = null;
    // let choice_timeout_duration = null;

    if (RTarray.length > 0){
      RTarray.sort((a, b) => a - b); // Sort RTarray in ascending order

      const upperQuartileIndex = Math.floor(RTarray.length * 0.75);
      const upperQuartileRT = RTarray[upperQuartileIndex];

      choice_timeout_duration = upperQuartileRT;
    } else {
      const upperQuartileRT = null;
      choice_timeout_duration = 3000;
    }

    if (jatosVersion == false){
      console.log(RTarray);
      console.log("Upper Quartile RT:", upperQuartileRT);
      console.log("choice_timeout_duration set to:", choice_timeout_duration);
    }

    return choice_timeout_duration;
  },
  response_ends_trial: true,
  data: {
    phase: 'ChoiceTest',
    image: jsPsych.timelineVariable('stimulus'),
    name: jsPsych.timelineVariable('name')
  },
  on_finish: function(data) {
    data.choice_timeout_duration = choice_timeout_duration;

    if (data.response === 0){
      if (data.name == "Plateau_Colour1" || data.name == "Transition1_Colour1" || data.name == "Transition2_Colour1" || data.name == "Transition3_Colour1"){
        data.responseAccuracy = 1;
      } else if (data.name == "Plateau_Colour2" || data.name == "Transition4_Colour1" || data.name == "Transition5_Colour1" || data.name == "Transition6_Colour1"){
        data.responseAccuracy = 0;
      }
    } else if (data.response === 1){
      if (data.name == "Plateau_Colour1" || data.name == "Transition1_Colour1" || data.name == "Transition2_Colour1" || data.name == "Transition3_Colour1"){
        data.responseAccuracy = 0;
      } else if (data.name == "Plateau_Colour2" || data.name == "Transition4_Colour1" || data.name == "Transition5_Colour1" || data.name == "Transition6_Colour1"){
        data.responseAccuracy = 1;
      }
    } else if (data.response == null){
      data.responseAccuracy = null;
      trials_to_repeat.push({
       stimulus: data.image,
       name: data.name,
     });
    }
  }
};

// Timeout trial screen
const timeout_screen = {
  type: jsPsychHtmlButtonResponse,
  stimulus: `<p style="font-size: 150%; text-align: center; color: red;">TOO SLOW!</p>
             <p style="text-align: center;">Please do not spend too long deciding but make a decision based on your general impression of the display.</p>`,
  choices: ['Continue'],
  data: { phase: 'timeout' },
  on_finish: function () {
    timeout_screen_displayed = true; // Mark that the timeout screen has been shown
  },
};

const choice_procedure = {
  timeline: [
    CommonColourChoice_trial,
    {
      timeline: [timeout_screen],
      conditional_function: function() {
        return jsPsych.data.get().last(1).values()[0].response === null;
      }
    }
  ]
};

var run_choice = {
  timeline: [choice_procedure],
  timeline_variables: choice_timeline_variables,
  randomize_order: true,
  loop_function: function() {
    if (trials_to_repeat.length > 0) {
      // Update the timeline variables with just the missed trials
      this.timeline_variables = [...trials_to_repeat];
      // Clear the trials_to_repeat array
      trials_to_repeat = [];
      return true; // Continue the loop with missed trials
    }
    return false; // End the timeline and move to next part of experiment
  }
};

// ******************* MAIN LOOPS ******************

const run_practice_block = {
    timeline: [run_prac_trial],
    loop_function: function() {
        trialNum++;
        trialNumInBlock++;
        if (trialNumInBlock < numChoicePracTrials) {return true} else {
            trialNum = 0;
            trialNumInBlock = 0;
            return false;
        };
    }
};


const run_practice_phase = {
    timeline: [run_practice_block, instructions_afterPractice],
    on_timeline_start: function() {exptPhase = 0; trialNumInBlock = 0; trialNum = 0},
    on_timeline_finish: function() {overallBlockNum++},
};


const break_conditional = {
  timeline: [blockBreakScreen1],
  conditional_function: function() {
    if (trialNumInBlock === numTrialsPerBlock) { //because start indexing at 0// for larger block size (numTrialsPerBlock/2)-1
      return true;
      // numBreaks++;
    } else {
      // otherwise skip the break trial
      return false;
    }
  }
};

const main_task_trial_block = {
    timeline: [run_full_trial,break_conditional],
    loop_function: function() {
        trialNum++;
        trialNumInBlock++;
        if (trialNumInBlock < numTrialsPerBlock) {return true} else {
            trialNumInBlock = 0;
            return false;
        };
    },
};

const run_main_task = {
    timeline: [main_task_trial_block, blockBreakScreen1],
    on_timeline_start: function() {
      exptPhase = 1;
      trialNumInBlock = 0;
      sampleLocationsPerBlock();
      sampleNumbersPerBlock();
    },
    loop_function: function() {
        blockNum++;
        overallBlockNum++;
        // shuffleArray(trialSelector);
        if (blockNum < numBlocks) {return true} else {return false};
    }
};

const test_strategyChoices = {timeline:[test_strategy,test_strategy_freeResponse]};
// const run_choice_trial = {timeline:[instr_commonColour,run_choice]};;
// const run_test_trial = {timeline:[end_searchtask,test_strategyChoices,test_aware_change,run_choice_trial]};
const run_test_trial = {timeline:[end_searchtask,test_strategyChoices,test_aware_change]};

// ******************* POST-EXPT QUESTIONS ******************

const expt_finished_questions = {
    type: jsPsychSurveyTextMLP,
    preamble:
    '<p style="font-size:130%; line-height:160%"><span style="color:red;"><b>Some final questions before you go!</b>'+
    '<p style="font-size:120%">Please type answers to the following questions in the boxes below.<br>Please respond to the questions honestly, you will not be penalised for your response.</p>',
    questions: [{prompt: "Were you distracted while you completed the task? e.g., by using your phone etc.", rows: 5, columns: 80}, {prompt: "Do you have any general comments about the experiment?", rows: 5, columns: 80}],
    post_trial_gap: 100,
    on_finish: function(data) {
        exptPhase = 4;
        var today = new Date();
        var endTime = today.getFullYear()+'-'+pad((today.getMonth()+1),2)+'-'+pad(today.getDate(),2)+'_'+pad(today.getHours(),2) + ":" + pad(today.getMinutes(),2) + ":" + pad(today.getSeconds(),2);
        jsPsych.data.get().addToLast({
            exptPhase: exptPhase,
            endTime: endTime
        });
        if (jatosVersion == true) {
            var result_for_JATOS = jsPsych.data.get().ignore(fieldsToIgnore).csv();
            jatos.submitResultData(result_for_JATOS);
        } else {
            jsPsych.data.get().ignore(fieldsToIgnore).localSave('csv','mydata.csv');
        };
    }
};



// ******************* INSTRUCTIONS ******************
// ***************************************************
// ***************************************************
// ******************* INSTRUCTIONS SET 0 ******************

// var imageFolder = 'resources/images/'
var search_ex_filename = imageFolder + 'search_example.png';
var search_ex_target_filename = imageFolder + 'search_example_targetCircle.png';

var search_ex2_filename = imageFolder + 'search_example_' + target_colourName1 + '.png';
var search_ex3_filename = imageFolder + 'search_example_' + target_colourName2 + '.png';


var display2 = 'hand_display.png';

var instr_hands_filename = imageFolder + display2;

var search_example_img = '<p style="text-align:center"><br><img src="' + search_ex_filename + '" style = "width:70%;height:70%;"><br></p>';
var search_example_target_img = '<p style="text-align:center"><br><img src="' + search_ex_target_filename + '" style = "width:70%;height:70%;"><br></p>';

var display_types_img = '<p style="text-align:center"><br><img src="' +search_ex2_filename +'" style = "width:49%;height:49%; margin-right: 0.5px;">'+
'<img src="' +search_ex3_filename +'" style = "width:49%;height:49%; margin-left: 0.5px"><br></p>';

var hands_example_img = '<p style="text-align:center"><br><img src="' + instr_hands_filename + '" style = "width:50%;height:50%;"><br></p>';
//

var ColourVisionImages = 'resources/images/ColourVision/';

var visionTest_img0 = ColourVisionImages + 'Ishihara_baseline12.png';
var visionTest_img1 = ColourVisionImages + 'Ishihara_06.png';
var visionTest_img2 = ColourVisionImages + 'Ishihara_42.png';
var visionTest_img3 = ColourVisionImages + 'Ishihara_74.png';


var allImageFilenames = [];
// allImageFilenames.push(medalDisplayFilename);
allImageFilenames.push(search_ex_filename);
allImageFilenames.push(search_ex2_filename);
allImageFilenames.push(search_ex3_filename);
allImageFilenames.push(instr_hands_filename);
allImageFilenames.push(visionTest_img0);
allImageFilenames.push(visionTest_img1);
allImageFilenames.push(visionTest_img2);
allImageFilenames.push(visionTest_img3);


const preload_images = {
    type: jsPsychPreload,
    auto_preload: false,
    show_progress_bar: false,
    images: allImageFilenames,
};


//colour vision test at the start//

const ColourTestInstructions = {
    type: jsPsychHtmlKeyboardResponseMLP,
    stimulus: function() {
        var tempTextHTML =
        '<p style="text-align:left">Before you begin the experiment, we would like to do a quick check of your colour vision.<br><br>'+
        'On the next few screens, you will be shown an image with a number inside it. Type the number that you see inside the image into the text box provided.<br><br>'+
        'Note that this is not a diagnostic test for colour vision, and no feedback on the outcome will be provided.';
        tempTextHTML += "<p>Press space when you are ready to continue</p>"
        return tempTextHTML;
    },
    choices: [' '],
    check_focus_interval: 1500,
    post_trial_gap: 0,
};

const end_colourtest = {
    type: jsPsychHtmlKeyboardResponseMLP,
    stimulus: function() {
        var tempTextHTML =
        '<p style="text-align:left">Thank you for completing the colour vision check. You are now ready to begin the main experiment.';
        tempTextHTML += "<p>Press space to receive instructions about the experiment.</p>"
        return tempTextHTML;
    },
    choices: [' '],
    check_focus_interval: 1500,
    post_trial_gap: 0,
};



var colour_vision_stimuli = [
  { stimulus: visionTest_img0, name: '12' },
  { stimulus: visionTest_img1, name: '6' },
  { stimulus: visionTest_img2, name: '42' },
  { stimulus: visionTest_img3, name: '74' }
];

const colour_check = {
    type: jsPsychSurveyHtmlForm,
    timeline_variables: colour_vision_stimuli,
    html: function(){
      // Embed the stimulus image in an HTML string
      var stimulusPath = jsPsych.timelineVariable('stimulus');
      return `
      <p style="text-align:center"><b>What is the number in the display?</b></p>
      <p style="text-align:center"><br><img src="${stimulusPath}" style="width:70%;height:70%;"></p>`+
      `<!-- Response -->` +
      `<b>Answer: &nbsp;</b></label><input id="colour_test" name = "colour_test" size="4" style="font-size:120%;" /required><br /><br />`
    },
    // choices: ['<p style="font-size:130%;line-height:0%;"><b>Next ></b></p>'],
    data: {
      phase: 'ColourVisionTeset',
      image: jsPsych.timelineVariable('stimulus'),
      name: jsPsych.timelineVariable('name')
    },
    on_finish: function(data) {
      // Compare the extracted response with the name of the trial
      if (data.response.colour_test === data.name.toString()) {
        data.responseAccuracy = 1;
      } else {
      data.responseAccuracy = 0;
      }
    }
};

const run_colour_check = {
  timeline: [colour_check],
  timeline_variables: colour_vision_stimuli,
  randomize_order: true,
};

const ColourTest = {
  timeline: [
    ColourTestInstructions, // Display the initial instructions
    {
      ...run_colour_check, // Run the colour check looping through all stimuli
      timeline: [colour_check], // Ensure it loops through the `colour_check` trials
    },
    end_colourtest // Display the end instructions
  ]
};


//stuff for experiment start//
var instructStr = [];
var Q_prompt = [];
var Q_answer = [];
var correctString = [];

var numQs = [];
var maxQs = 4;

for (ii = 0; ii < maxQs; ii++) {
    Q_prompt[ii] = [];
    Q_answer[ii] = [];
    correctString[ii] = [];
};


if (LearningCondition == "Experience"){
  var conditionText = '';
}else if (LearningCondition == "Instructed"){
  var conditionText = ' Before the start of each trial, you will be told the number of '+target_colourName1+' and '+target_colourName2+' squares in the upcoming display.';
}

if (target_colourName1 == 'ORANGE'){
  var aOran1 = 'an';
  var aOran2 = 'a';
}else {
  var aOran1 = 'a';
  var aOran2 = 'an';
}

instructStr[0] = [
    '<p style="text-align:left">WELCOME TO THE EXPERIMENT!<br><p style="text-align:left">In this study, you will be asked to complete a <b>CHOICE SEARCH TASK</b>.<br><br>Each trial will start with a cross appearing &ndash; this tells you that the trial is about to begin. A set of squares will then appear. You can see an example below:<br></p>' + search_example_img,
    '<p style="text-align:left">In this task, you will be searching for a target square.<br><br><b>The target will be '+aOran1+' '+target_colourName1+' or '+target_colourName2+' square with a number between 2 and 5</b>.'+
    '<p style="text-align:left">On every trial, there is <b>ONE '+target_colourName1+' and ONE '+target_colourName2+' target</b>. When you find a target, press the key that corresponds to the number: 2, 3, 4 or 5. You are free to decide which target you want to search for on each trial. The two targets will always have DIFFERENT numbers.<br><br>Use the numbers on the top row of your keyboard or the numberpad to make your response.'+ search_example_target_img,
    // '<p style="text-align:left">There are also '+IrrColourName+' squares in every display but these are NEVER the target so try your best to ignore them as attending to them will only slow you down!'+ search_example_target_img,
    '<p style="text-align:left">The number of '+target_colourName1+' and '+target_colourName2+' squares in the display will change. Sometimes there will be more '+target_colourName1+' squares, like the example on the left, and sometimes there will be more '+target_colourName2+' squares, like the example on the right.' +
    '<p style="text-align:left">You may find it easier to search for the target that appears in the less-common colour in the display.'+conditionText+''+
    '<p style="text-align:left">REMEMBER: Your task is always to find and report the number in a <b>target</b> square. There will always be one target in '+target_colourName1+' and one target in '+target_colourName2+' in each display. There are also '+IrrColourName+' squares in every display but these are NEVER the target so try your best to ignore them as they will only slow you down!'+display_types_img,
    '<p style="text-align:left">Once you have made a response, the display will disappear.<br><br>If your response was CORRECT, you get to move on to the next trial.<br><br>If your response was INCORRECT or TOO SLOW, you will have to wait a little longer before the next trial begins. So, try and be quick and as accurate as you can when making your response! </p>'
  ];
numQs[0] = 3;

Q_prompt[0][0] = 'Which of these options is <B>CORRECT</B>?';
Q_answer[0][0] = [" I should make a response based on the number in ANY coloured square in the display.", " I should only make a response based on the number inside a TARGET square in the display."];
correctString[0][0] = Q_answer[0][0][1];

Q_prompt[0][1] = 'Which of the following is <B>TRUE</B> about the target square?';
Q_answer[0][1] = [" The target square is either "+aOran1+" "+target_colourName1+" or "+aOran2+" "+target_colourName2+" square with a number between 2 and 5 (inclusive).", " The target square is either "+aOran1+" "+target_colourName1+" or "+aOran2+" "+target_colourName2+" square with a number greater than 5."];
correctString[0][1] = Q_answer[0][1][0];

Q_prompt[0][2] = 'Which of these options is <B>FALSE</B>?';
Q_answer[0][2] = [" I should ignore all "+IrrColourName+" squares as they are NEVER the target.", " There is one "+target_colourName1+" and one "+target_colourName2+" target square in each display.", " I should respond to ANY number between 2 and 5 even if they are not "+target_colourName1+" or "+target_colourName2+"."];
correctString[0][2] = Q_answer[0][2][2];


// ******************* INSTRUCTIONS SET 1 ******************


// ******************* INSTRUCTIONS SET 2 ******************

instructStr[1] = [
    '<p style="text-align:left;">From now on, we will track your performance on the task.<br><br>'+
    'At the end of each block of trials, you will be told how ACCURATE and how QUICK you were to report the number in the target square.<br>Try and see if you can get FASTER and MORE ACCURATE across the experiment!<br><br>'+
    'You will have the opportunity to take a break in between blocks of trials. Use this time to relax. You can continue whenever you\'re ready.</p><br>',
];
//
numQs[1] = 2;

Q_prompt[1][0] = '<b>Which of these options is correct?</b>';
Q_answer[1][0] = [" I will only see one type of search display during this experiment.", " I will see different search displays during the experiment, but my goal is always to report the orientation of the line in the TARGET shape."];
correctString[1][0] = Q_answer[1][0][1];

Q_prompt[1][1] = '<b>Which of these options is correct?</b>';
Q_answer[1][1] = [" The target shape is always in a different colour", " The target shape is always grey"];
correctString[1][1] = Q_answer[1][1][1];


// ******************* SET UP INSTRUCTION LOOPS ******************

const show_instructions = {
    type: jsPsychInstructions,
    pages: function() {return instructStr[instSet]},
    show_clickable_nav: true,
    post_trial_gap: 0
};

var instructions_repeat = true;

const instructions_check = {
    type: jsPsychSurveyMultiChoiceMLP,
    preamble: ["<p style='text-align:center;'>Check your knowledge before you continue!</p>"],
    questions: function() {
        var qItems = [];
        for (ii = 0; ii < numQs[instSet]; ii++) {
            qItems[ii] = {prompt: Q_prompt[instSet][ii], options: Q_answer[instSet][ii], required: true};
        }
        return qItems;
    },
    post_trial_gap: 0,
    on_finish: function(data) {
        instructions_repeat = false;
        for (ii = 0; ii < numQs[instSet]; ii++) {
            if (data.response['Q'+ii]!=correctString[instSet][ii]) {instructions_repeat = true}
        }
        jsPsych.data.get().addToLast({
            instSet: instSet,
            instruct_qs: 1
        });
    }
};

const instructions_check_failed_display = {
    type: jsPsychHtmlButtonResponse,
    stimulus: '<p><b>Unfortunately, at least one of your answers was incorrect.</b></p>',
    choices: ['<p>Click here to read the instructions again</p>'],
    button_html: '<button class="fancyButtonRed" style="vertical-align:middle"><span>%choice%</span></button><br><br>',
    post_trial_gap: 100
};


const instructions_check_failed_conditional = {
    timeline: [instructions_check_failed_display],
    conditional_function: function() {return instructions_repeat}      // If this is true, it will execute timeline (show failure screen)
};

const ready_to_continue = {
    type: jsPsychHtmlKeyboardResponseMLP,
    stimulus: function() {
        var successStr = '';
        if (instSet == 0) {
            successStr = '<p style="text-align:center;font-size:120%"><b>Well done &ndash; all your answers were correct!</b><br><br>You will now practise the choice search task.<br><br>REMEMBER: target is '+aOran1+' '+target_colourName1+' or '+target_colourName2+' square<br>with a number between 2 and 5.<br></p><p style="text-align:center;font-size:105%">Please press space when you are ready to begin practice.</p>';
        } else if (instSet == 1) {
            successStr = '<p>Please press space when you are ready to begin<br>the experiment</p>';
        };
        return successStr;
    },
    choices: [' '],
};

var loop_instructions = {
    timeline: [show_instructions, instructions_check, instructions_check_failed_conditional],
    loop_function: function() {return instructions_repeat}  // If instructions_repeat remains true, this will keep looping; if it becomes false, it will move on.
};


var practice_instructions_pt1 = {
    on_timeline_start: function() {instSet = 0; instructions_repeat = true;},
    timeline: [loop_instructions,ready_to_continue]
};

var main_instructions = {
    on_timeline_start: function() {instSet = 1; instructions_repeat = true;},
    timeline: [show_instructions, ready_to_continue]
};



// ******************* CONSENT, DEMOGRAPHICS AND DEBRIEF ******************

var studyName = 'Looking for Shapes';

var piscf_info = {};

piscf_info.task = {};
piscf_info.task.time = '60 mins';
piscf_info.task.credit = '7.00 GBP';   // '1 SONA credit'

piscf_info.ethics = {};
piscf_info.ethics.approval = '3604';
piscf_info.ethics.name = studyName;

var mWidth = '10px 0px';

const piscf = {
    type: jsPsychHtmlButtonResponse,
    stimulus:function() {
        document.getElementById("jspsychTargetMLP").style.position = "static";
        document.getElementById("jspsychTargetMLP").style.height = "100%";
        document.getElementById("jspsychTargetMLP").style.width = "100%";
        document.getElementById("jspsychTargetMLP").style.top = "0%";
        document.getElementById("jspsychTargetMLP").style.left = "0%";
        document.getElementById("jspsychTargetMLP").style.margin = "0";

        if (realVersion == false) {console.log('pID: ' + subject_id)};

        var sf = '90%';
        var lh = '150%';

        var tempStr;
        if (sonaVersion) {tempStr = 'SONA'} else if (prolificVersion) {tempStr = 'Prolific'};

        var htmlStr = '<p style="text-align:center;"><b>UNSW SYDNEY SCHOOL OF PSYCHOLOGY<br>' +
        'PARTICIPANT INFORMATION STATEMENT AND CONSENT FORM</b><br>' + piscf_info.ethics.name + '<br></p><p>Please read over the information below and click the button at the bottom of the page if you consent to participate in the study.</p>';

        htmlStr += '<ol style="text-align:left;line-height:190%;margin:'+mWidth+';font-size:'+sf+';line-height:'+lh+';">' +
        '<li> <p><b>What is the research study about?</b><br>You are invited to take part in this research study. The research study aims to investigate the role of attention in visual search, by asking you to search for shapes as quickly and accurately as possible. You have been invited because you registered to participate in this study via  ' + tempStr + ', and your contact details were obtained from ' + tempStr + '.</p></li>' +
        '<li> <p><b>Who is conducting this research?</b><br>The study is being carried out by the following researcher(s): Professor Mike Le Pelley and Dr Julie Chow, School of Psychology, UNSW Sydney.</p></li>' +
        '<li> <p><b>Inclusion/Exclusion Criteria</b><br>Before you decide to participate in this research study, you should meet the following criterion: <b><i>Normal colour vision</b></i></p></li>' +
        '<li> <p><b>Do I have to take part in this research study?</b><br>Participation in this research study is voluntary. If you do not want to take part, you do not have to. If you decide to take part and later change your mind, you are free to withdraw from the study at any stage (See Item 11).</p></li>' +
        '<li> <p><b>What does participation in this research require, and are there any risks involved?</b><br>If you decide to take part in the research study, we will ask you to complete a visual search task. In this task, you will be asked to search for and respond to shapes that appear on the screen. We do not expect this research to cause any harm. However, you may skip any or all written or verbal questions if you wish. Please let the researchers know if you need any assistance for any reason.</p></li>' +
        '<li> <p><b>Total participation time</b><br>In total, participation in this study will require ' + piscf_info.task.time + '.</p></li>' +
        '<li> <p><b>Recompense to participants</b><br>You will receive ' + piscf_info.task.credit + ' for completing the study.<br></li>' + // In addition, you will be able to earn points during the study, and the 25% of participants who earn the most points will receive ' + prizeStr +'.
        '<li> <p><b>What are the possible benefits to participation?</b><br>We cannot promise that you will receive any benefits from this study, but we hope to use the findings from this study to better understand the role of attention in visual search.</p></li>' +
        '<li> <p><b>What will happen to information about me?</b><br>The information that you give us will be kept for 5 years after the project\'s completion. We will store information about you in a non-identifiable format at UNSW (Kensington Campus).<br>Researchers at UNSW are requested to store their aggregated research data in the UNSW data repository, this is a system called ResData. Once the aggregated data are deposited into this repository, they will be retained in this system permanently, but in a format where your data will not be individually identifiable.<br>Your non-identifiable information will be used in publications and reports based on this research study. Information collected for this research project may be made available to other research projects in de-identified form only.</p></li>' +
        '<li> <p><b>How and when will I find out what the results of the research study are?</b><br>The research team intend to publish and/ report the results of the research study in a variety of ways. All information published will be done in a way that will not identify you. If you would like to receive a copy of the results you can let the research team know by emailing Prof Mike Le Pelley: m.lepelley@unsw.edu.au. We will only use these details to send you the results of the research.</p></li>' +
        '<li> <p><b>What if I want to withdraw from the research study?</b><br>If you do consent to participate, you may withdraw at any time. You do not have to give any reason for withdrawing. However, please let the researcher know by email. Your decision not to participate or to withdraw from the study will not affect your relationship with UNSW Sydney. If you decide to withdraw from the research study, the researchers will not collect additional information from you. Any identifiable information about you will be withdrawn from the research project.</p></li>' +
        '<li> <b>What should I do if I have further questions about my involvement in the research study?</b><br>If you require further information regarding this study or if you have any problems that may be related to your involvement in the study, you can contact the following member/s of the research team:<p class="conDets"><b><i>Research Team Contact Details</b></i><br><b>Chief Investigator:</b> Prof Mike Le Pelley<br><b>Position:</b> Professor<br><b>Telephone:</b> +61 2 9065 1458<br><b>Email:</b> m.lepelley@unsw.edu.au<b><br><br>Partner Investigator:</b> Dr Julie Chow<br><b>Position:</b> Postdoctoral Research Associate<br><b>Email:</b> julie.chow@unsw.edu.au</p></li>' +
        '<li> <b>What if I have a complaint or any concerns about the research study?</b><br>If you have a complaint regarding any aspect of the study or the way it is being conducted, please contact the UNSW Human Ethics Coordinator:<p class="conDets"><b><i>Complaints Contact</b></i><br><b>Position:</b> UNSW Human Research Ethics Coordinator<br><b>Telephone:</b> +61 2 9385 6222<br><b>Email:</b> humanethics@unsw.edu.au<br><b>HC Reference Number:</b> '+piscf_info.ethics.approval+'</span></p></li>' +
        '</ol>';

        return htmlStr;
    },
    choices: ['<p style="font-size:130%;line-height:0%;"><b>Please click here when you have read the above information</b></p>'],
    button_html: '<button style="vertical-align:middle;line-height:150%"><span>%choice%</span></button><br><br>'
};

var consentDenied = true;

const consent_form = {
    type: jsPsychHtmlButtonResponse,
    stimulus: function() {
        document.getElementById("jspsychTargetMLP").style.position = "static";
        document.getElementById("jspsychTargetMLP").style.height = "100%";
        document.getElementById("jspsychTargetMLP").style.width = "100%";
        document.getElementById("jspsychTargetMLP").style.top = "0%";
        document.getElementById("jspsychTargetMLP").style.left = "0%";
        document.getElementById("jspsychTargetMLP").style.margin = "0";
        var sf = '90%';
        var lh = '150%';

        var htmlStr = '<h2 style="text-align:left;line-height:190%;margin:'+mWidth+';">Consent form &ndash; Participant providing own consent</h2><p style="text-align:left;font-weight:bold;">Declaration by the participant</p>' +
        '<ul style="text-align:left;line-height:190%;margin:'+mWidth+';"><li>I understand I am being asked to provide consent to participate in this research study.</li>' +
        '<li>I have read the Participant Information Sheet or someone has read it to me in a language that I understand.</li>' +
        '<li>I understand the purposes, study tasks and risks of the research described in the study.</li>' +
        '<li>I provide my consent for the information collected about me to be used for the purpose of this research study only.</li>' +
        '<li>I have been given contact details of the researchers to enable me to ask questions about my participation.</li>' +
        '<li>I freely agree to participate in this research study as described and understand that I am free to withdraw at any time during the study and withdrawal will not affect my relationship with any of the named organisations and/or research team members.</li></ul><br>' +
        '<p><b>Please click on the appropriate button below.</b></p><br>';

        return htmlStr;
    },
    choices: ['<p style="font-size:130%;line-height:120%;"><b>I consent<br>to participate</b></p>', '<p style="font-size:130%;line-height:120%;"><b>I DO NOT consent<br>to participate</b></p>'],
    button_html: ['<button class="consentButton" style="vertical-align:middle;width:200px;"><span>%choice%</span></button><br><br>', '<button class="noConsentButton" style="vertical-align:middle;width:200px;"><span>%choice%</span></button><br><br>'],
    margin_horizontal: '50px',
    on_finish: function(data) {
        if (data.response == '0') {
            consentDenied = false;
            document.getElementById("jspsychTargetMLP").style.position = "absolute";
            document.getElementById("jspsychTargetMLP").style.width = winWidth + "px";
            document.getElementById("jspsychTargetMLP").style.marginLeft = -winWidth/2+"px";
            document.getElementById("jspsychTargetMLP").style.left = "50%";
            var today = new Date();
            var startTime = today.getFullYear()+'-'+pad((today.getMonth()+1),2)+'-'+pad(today.getDate(),2)+'_'+pad(today.getHours(),2) + ":" + pad(today.getMinutes(),2) + ":" + pad(today.getSeconds(),2);

            jsPsych.data.get().addToLast({
                subjectID: subject_id,
                resultsID: results_id,
                startTime: startTime,
            });

            if (jatosVersion == true) {
                // var result_for_JATOS = jsPsych.data.get().ignore(fieldsToIgnore).json();
                var result_for_JATOS = jsPsych.data.get().ignore(fieldsToIgnore).csv();
                jatos.submitResultData(result_for_JATOS);
            };
        }
    }
}

const no_consent_given = {
    type: jsPsychHtmlKeyboardResponseMLP,
    stimulus: '<p style="text-align:centre;font-size:130%;line-height:160%;">You have chosen not to participate in this experiment.<br>It\'s now OK to close this window (please do not use the "back" button on your browser).<br><br><br></p>',
    choices: "NO_KEYS"
}

var consent_conditional = {
    timeline: [no_consent_given],
    conditional_function: function() {return consentDenied}
}

var run_consent_procedure = {
    timeline: [piscf, consent_form, consent_conditional]
}

const do_not_close_instructions = {
    type: jsPsychHtmlKeyboardResponseMLP,
    stimulus: '<p style="text-align:left;font-size:120%"><b>Please complete this task in a quiet environment, with as few distractions as possible &ndash; please turn off your phone (or put it on silent).<br><br>Please do not close this window or use the "Back" button on your browser until you are told that the experiment is complete!</b><br><br></p><p style="text-align:center;font-size:110%">Please press space when you are ready to continue</p>',
    choices: [' '],
    check_focus_interval: 1500,
    post_trial_gap: 0,
    post_trial_gap: 0
};

const demographics = {
    type: jsPsychDemographicResponse,
    stimulus:     '<p style="text-align:left;font-size:120%">If you are happy to do so, please enter demographic information below.<br>You can leave an item blank if you would prefer not to say.<br><br></p>' +
    '<p style="text-align:left;font-size:120%;">' +
    '<!-- Gender -->' +
    '<label for="gender"><b>Gender: &nbsp;</b></label>' +
    '<input type="radio" name="gender" value="male" /> Male &nbsp; ' +
    '<input type="radio" name="gender" value="female" /> Female &nbsp;' +
    '<input type="radio" name="gender" value="other" /> Other<br /><br />' +
    '<!-- Age -->' +
    '<label for="age"><b>Age: &nbsp;</b></label><input id="age" name="age" size="4" style="font-size:120%;" /><br /><br />' +
    '<!-- Language -->' +
    '<label for="language"><b>Native language(s): &nbsp;</b></label>' +
    '<input id="language" name="language" size="25" style="font-size:120%;" /><br /><br />',

    choices: ['<p style="font-size:130%;line-height:0%;"><b>Next ></b></p>'],

    on_finish: function(trial_data) {
        jsPsych.data.get().addToLast({
            gender: p_gender,
            age: p_age,
            language: p_language
        });
    }
};


var completion_url = '';

const browser_check = {
    type: jsPsychBrowserCheck,
    features: ['mobile'],
    inclusion_function: (data) => {return data.mobile === false},
    exclusion_message: '<p>You must use a desktop/laptop computer to participate in this experiment.</p>',
    post_trial_gap: 0,
}

// ******************* FADES ******************

var fadeToBlack;
var fadeToWhite;
var fadeStep = 2;
var lightnessVal;

var fadeDuration = 17 * 100 / fadeStep;  // Assume 60 Hz refresh (so 17ms frame update)


var fadeToBlackTrial = {
    type: jsPsychHtmlKeyboardResponseMLP,
    stimulus: "",
    trial_duration: 1,
    response_ends_trial: false,
    post_trial_gap: fadeDuration + initialPauseDuration,
    on_finish: function() {
        lightnessVal = 100;
        requestAnimationFrame(fadeToBlackFn);
    }
};

var fadeToWhiteTrial = {
    type: jsPsychHtmlKeyboardResponseMLP,
    stimulus: "",
    trial_duration: 1,
    response_ends_trial: false,
    post_trial_gap: fadeDuration,
    on_finish: function() {
        lightnessVal = 0;
        requestAnimationFrame(fadeToWhiteFn);
    }
};

var usingComputer = true;
(function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) usingComputer = false;})(navigator.userAgent||navigator.vendor||window.opera);

function detectMob() {
    const toMatch = [/Android/i,/webOS/i,/iPhone/i,/iPad/i,/iPod/i,/BlackBerry/i,/Windows Phone/i];
    return toMatch.some((toMatchItem) => {
        return navigator.userAgent.match(toMatchItem);
    });
}
var usingMob = detectMob()
if (usingMob == true) {usingComputer = false};

var using_mobile_device = {
    type: jsPsychInstructions,
    pages: ['<p style="text-align:left;font-size:150%">You seem to be using a mobile device so you will not currently be able to complete this study.<br><br>To complete this study, please visit this website using a computer with a keyboard and mouse/trackpad.</p>']
};


// ******************* SET TIMELINE AND RUN EXPT ******************


var exptTimeline = [];

instSet = 0;

if (usingComputer) {
    exptTimeline.push(browser_check);
    exptTimeline.push(preload_images);
    exptTimeline.push(preload_test_images);
    exptTimeline.push(do_not_close_instructions);
    // exptTimeline.push(run_consent_procedure);
    exptTimeline.push({
        type: jsPsychFullscreen,
        fullscreen_mode: true,
        delay_after: 500,
    });
    // exptTimeline.push(demographics);
    exptTimeline.push(ColourTest);
    exptTimeline.push(practice_instructions_pt1);
    exptTimeline.push(fadeToBlackTrial);
    exptTimeline.push(run_practice_phase);
    exptTimeline.push(fadeToWhiteTrial);
    exptTimeline.push(main_instructions);
    exptTimeline.push(fadeToBlackTrial);
    exptTimeline.push(run_main_task);
    exptTimeline.push(fadeToWhiteTrial);
    exptTimeline.push(run_test_trial);
    exptTimeline.push(expt_finished_questions);
    exptTimeline.push({
        type: jsPsychFullscreen,
        fullscreen_mode: false,
        delay_after: 500,
    });
    // exptTimeline.push(debrief);
} else {
    exptTimeline.push(using_mobile_device);
}

var finish_msg = 'Experiment finished! Message about SONA/Prolific goes here';


jsPsych.data.addProperties({
    rSeed: rSeed,
    LearningCondition: LearningCondition,
    colourBalance: colourBalance, //which colour is majority in trial type1
    sample: sample
});


if (jatosVersion) {
    jatos.onLoad(function () {
        var completion_url='';
        var tempStr='';
        if (sonaVersion) {
            subject_id = jatos.urlQueryParameters.pID;
            var finish_url_base = jatos.studyJsonInput.finish_url_base;
            completion_url = finish_url_base + subject_id;
            tempStr = 'Sona and receive your credit.'
        } else if (prolificVersion) {
            subject_id = jatos.urlQueryParameters.PROLIFIC_PID;
            results_id = jatos.urlQueryParameters.SESSION_ID;
            completion_url = 'https://app.prolific.com/submissions/complete?cc=CJ136ESZ';
            tempStr = 'Prolific and complete the study.'
        }
        finish_msg = 'You have now completed all of the tasks &ndash; thanks for taking part!<br>We really appreciate the time you\'ve taken.<br><br><b>Please <a href="' + completion_url + '">click here</a> to be returned to ' + tempStr + '</b><br><br><br></p>';
        jsPsych.run(exptTimeline);
    });
} else {
    jsPsych.run(exptTimeline);
};


function fadeToBlackFn() {
    lightnessVal -= fadeStep;
    if (lightnessVal <= 0) {
        lightnessVal = 0;
        document.getElementById("jspsychTargetMLP").style.color = "white";
    };
    document.body.style.backgroundColor = "hsl(0,0%,"+lightnessVal+"%)";
    if (lightnessVal > 0) {
        requestAnimationFrame(fadeToBlackFn);
    };
};

function fadeToWhiteFn() {
    lightnessVal += fadeStep;
    if (lightnessVal >= 100) {
        lightnessVal = 100;
        document.getElementById("jspsychTargetMLP").style.color = "black";
    };
    document.body.style.backgroundColor = "hsl(0,0%,"+lightnessVal+"%)";
    if (lightnessVal < 100) {
        requestAnimationFrame(fadeToWhiteFn);
    };
};

function shuffleArray(myArray) {
    var randNum, tempStore, j;
    for (j = myArray.length; j; j--) {
        randNum = Math.floor(Math.random() * j);
        tempStore = myArray[j - 1];
        myArray[j - 1] = myArray[randNum];
        myArray[randNum] = tempStore;
    }
};

function simpleShuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]]; // Swap elements
  }
  return array;
}


function numberWithCommas(x) {
    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
};

function pad(n, len) {
    s = n.toString();
    if (s.length < len) {
        s = ('000' + s).slice(-len);
    }
    return s;
};

function getRndIntIncl(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive
}

function getRndInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive
}

function endExperiment(dataset, callback){
  jsPsych.data.displayData()
}


</script>
</html>
